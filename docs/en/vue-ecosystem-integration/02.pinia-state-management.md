# Pinia State Management with Element Plus

## Overview

Pinia is the official state management library for Vue.js applications, providing a simple, type-safe, and intuitive API. When combined with Element Plus, it enables sophisticated state management for complex UI interactions, form handling, and data synchronization across components.

## Installation and Setup

### Basic Installation

```bash
# Install Pinia
npm install pinia

# For TypeScript support
npm install @pinia/nuxt  # If using Nuxt
```

### Application Setup

```javascript
// main.js
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
import App from './App.vue'

const app = createApp(App)
const pinia = createPinia()

// Add Pinia plugins
pinia.use(({ store }) => {
  // Add global properties to all stores
  store.$router = markRaw(router)
  store.$notify = ElNotification
  store.$message = ElMessage
})

app.use(pinia)
app.use(ElementPlus)
app.mount('#app')
```

### TypeScript Configuration

```typescript
// types/pinia.d.ts
import 'pinia'
import type { Router } from 'vue-router'
import type { ElNotification, ElMessage } from 'element-plus'

declare module 'pinia' {
  export interface PiniaCustomProperties {
    $router: Router
    $notify: typeof ElNotification
    $message: typeof ElMessage
  }
}
```

## Core Store Patterns

### Authentication Store

```typescript
// stores/auth.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { ElMessage, ElNotification } from 'element-plus'
import type { User, LoginCredentials, RegisterData } from '@/types/auth'
import { authApi } from '@/api/auth'
import { useRouter } from 'vue-router'

export const useAuthStore = defineStore('auth', () => {
  // State
  const user = ref<User | null>(null)
  const token = ref<string | null>(localStorage.getItem('token'))
  const isLoading = ref(false)
  const loginAttempts = ref(0)
  const lastLoginTime = ref<Date | null>(null)
  const permissions = ref<string[]>([])
  const roles = ref<string[]>([])
  
  // Getters
  const isAuthenticated = computed(() => !!token.value && !!user.value)
  const isAdmin = computed(() => roles.value.includes('admin'))
  const isModerator = computed(() => roles.value.includes('moderator'))
  const userInitials = computed(() => {
    if (!user.value) return ''
    const names = user.value.name.split(' ')
    return names.map(name => name.charAt(0)).join('').toUpperCase()
  })
  
  const hasPermission = computed(() => {
    return (permission: string) => permissions.value.includes(permission)
  })
  
  const hasRole = computed(() => {
    return (role: string) => roles.value.includes(role)
  })
  
  // Actions
  const login = async (credentials: LoginCredentials) => {
    try {
      isLoading.value = true
      loginAttempts.value++
      
      const response = await authApi.login(credentials)
      const { user: userData, token: authToken, permissions: userPermissions, roles: userRoles } = response.data
      
      // Update state
      user.value = userData
      token.value = authToken
      permissions.value = userPermissions
      roles.value = userRoles
      lastLoginTime.value = new Date()
      
      // Persist token
      localStorage.setItem('token', authToken)
      localStorage.setItem('user', JSON.stringify(userData))
      
      // Reset login attempts on successful login
      loginAttempts.value = 0
      
      ElMessage.success(`Welcome back, ${userData.name}!`)
      
      return { success: true, user: userData }
    } catch (error: any) {
      ElMessage.error(error.message || 'Login failed')
      
      // Handle too many attempts
      if (loginAttempts.value >= 3) {
        ElNotification.warning({
          title: 'Security Notice',
          message: 'Too many login attempts. Please try again later.',
          duration: 5000
        })
      }
      
      return { success: false, error: error.message }
    } finally {
      isLoading.value = false
    }
  }
  
  const register = async (data: RegisterData) => {
    try {
      isLoading.value = true
      
      const response = await authApi.register(data)
      const { user: userData, token: authToken } = response.data
      
      user.value = userData
      token.value = authToken
      
      localStorage.setItem('token', authToken)
      localStorage.setItem('user', JSON.stringify(userData))
      
      ElMessage.success('Registration successful!')
      
      return { success: true, user: userData }
    } catch (error: any) {
      ElMessage.error(error.message || 'Registration failed')
      return { success: false, error: error.message }
    } finally {
      isLoading.value = false
    }
  }
  
  const logout = async () => {
    try {
      if (token.value) {
        await authApi.logout()
      }
    } catch (error) {
      console.error('Logout API error:', error)
    } finally {
      // Clear state regardless of API success
      user.value = null
      token.value = null
      permissions.value = []
      roles.value = []
      lastLoginTime.value = null
      
      localStorage.removeItem('token')
      localStorage.removeItem('user')
      
      ElMessage.info('Logged out successfully')
    }
  }
  
  const refreshToken = async () => {
    try {
      const response = await authApi.refreshToken()
      const { token: newToken } = response.data
      
      token.value = newToken
      localStorage.setItem('token', newToken)
      
      return newToken
    } catch (error) {
      // Token refresh failed, logout user
      await logout()
      throw error
    }
  }
  
  const updateProfile = async (profileData: Partial<User>) => {
    try {
      isLoading.value = true
      
      const response = await authApi.updateProfile(profileData)
      const updatedUser = response.data
      
      user.value = { ...user.value, ...updatedUser }
      localStorage.setItem('user', JSON.stringify(user.value))
      
      ElMessage.success('Profile updated successfully')
      
      return { success: true, user: user.value }
    } catch (error: any) {
      ElMessage.error(error.message || 'Profile update failed')
      return { success: false, error: error.message }
    } finally {
      isLoading.value = false
    }
  }
  
  const changePassword = async (currentPassword: string, newPassword: string) => {
    try {
      isLoading.value = true
      
      await authApi.changePassword({ currentPassword, newPassword })
      
      ElMessage.success('Password changed successfully')
      
      return { success: true }
    } catch (error: any) {
      ElMessage.error(error.message || 'Password change failed')
      return { success: false, error: error.message }
    } finally {
      isLoading.value = false
    }
  }
  
  const initializeAuth = () => {
    const storedToken = localStorage.getItem('token')
    const storedUser = localStorage.getItem('user')
    
    if (storedToken && storedUser) {
      token.value = storedToken
      user.value = JSON.parse(storedUser)
      
      // Verify token validity
      authApi.verifyToken().catch(() => {
        logout()
      })
    }
  }
  
  return {
    // State
    user: readonly(user),
    token: readonly(token),
    isLoading: readonly(isLoading),
    loginAttempts: readonly(loginAttempts),
    lastLoginTime: readonly(lastLoginTime),
    permissions: readonly(permissions),
    roles: readonly(roles),
    
    // Getters
    isAuthenticated,
    isAdmin,
    isModerator,
    userInitials,
    hasPermission,
    hasRole,
    
    // Actions
    login,
    register,
    logout,
    refreshToken,
    updateProfile,
    changePassword,
    initializeAuth
  }
})
```

### Application State Store

```typescript
// stores/app.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { BreadcrumbItem, NotificationItem } from '@/types/app'

export const useAppStore = defineStore('app', () => {
  // State
  const isLoading = ref(false)
  const loadingText = ref('Loading...')
  const sidebarCollapsed = ref(false)
  const theme = ref<'light' | 'dark'>('light')
  const language = ref('en')
  const breadcrumb = ref<BreadcrumbItem[]>([])
  const notifications = ref<NotificationItem[]>([])
  const cachedViews = ref<string[]>([])
  const visitedViews = ref<string[]>([])
  const deviceType = ref<'desktop' | 'tablet' | 'mobile'>('desktop')
  const windowSize = ref({ width: window.innerWidth, height: window.innerHeight })
  
  // Getters
  const isMobile = computed(() => deviceType.value === 'mobile')
  const isTablet = computed(() => deviceType.value === 'tablet')
  const isDesktop = computed(() => deviceType.value === 'desktop')
  const unreadNotifications = computed(() => 
    notifications.value.filter(n => !n.read).length
  )
  
  // Actions
  const setLoading = (loading: boolean, text = 'Loading...') => {
    isLoading.value = loading
    loadingText.value = text
  }
  
  const toggleSidebar = () => {
    sidebarCollapsed.value = !sidebarCollapsed.value
    localStorage.setItem('sidebarCollapsed', String(sidebarCollapsed.value))
  }
  
  const setSidebarCollapsed = (collapsed: boolean) => {
    sidebarCollapsed.value = collapsed
    localStorage.setItem('sidebarCollapsed', String(collapsed))
  }
  
  const setTheme = (newTheme: 'light' | 'dark') => {
    theme.value = newTheme
    localStorage.setItem('theme', newTheme)
    
    // Apply theme to document
    document.documentElement.setAttribute('data-theme', newTheme)
    
    if (newTheme === 'dark') {
      document.documentElement.classList.add('dark')
    } else {
      document.documentElement.classList.remove('dark')
    }
  }
  
  const toggleTheme = () => {
    setTheme(theme.value === 'light' ? 'dark' : 'light')
  }
  
  const setLanguage = (lang: string) => {
    language.value = lang
    localStorage.setItem('language', lang)
  }
  
  const setBreadcrumb = (items: BreadcrumbItem[]) => {
    breadcrumb.value = items
  }
  
  const addNotification = (notification: Omit<NotificationItem, 'id' | 'timestamp'>) => {
    const newNotification: NotificationItem = {
      ...notification,
      id: Date.now().toString(),
      timestamp: new Date(),
      read: false
    }
    
    notifications.value.unshift(newNotification)
    
    // Limit notifications to 50
    if (notifications.value.length > 50) {
      notifications.value = notifications.value.slice(0, 50)
    }
  }
  
  const markNotificationAsRead = (id: string) => {
    const notification = notifications.value.find(n => n.id === id)
    if (notification) {
      notification.read = true
    }
  }
  
  const markAllNotificationsAsRead = () => {
    notifications.value.forEach(n => n.read = true)
  }
  
  const removeNotification = (id: string) => {
    const index = notifications.value.findIndex(n => n.id === id)
    if (index > -1) {
      notifications.value.splice(index, 1)
    }
  }
  
  const clearNotifications = () => {
    notifications.value = []
  }
  
  const addCachedView = (viewName: string) => {
    if (!cachedViews.value.includes(viewName)) {
      cachedViews.value.push(viewName)
    }
  }
  
  const removeCachedView = (viewName: string) => {
    const index = cachedViews.value.indexOf(viewName)
    if (index > -1) {
      cachedViews.value.splice(index, 1)
    }
  }
  
  const clearCachedViews = () => {
    cachedViews.value = []
  }
  
  const addVisitedView = (viewName: string) => {
    if (!visitedViews.value.includes(viewName)) {
      visitedViews.value.push(viewName)
      
      // Limit visited views to 20
      if (visitedViews.value.length > 20) {
        visitedViews.value = visitedViews.value.slice(-20)
      }
    }
  }
  
  const setDeviceType = (type: 'desktop' | 'tablet' | 'mobile') => {
    deviceType.value = type
  }
  
  const updateWindowSize = (width: number, height: number) => {
    windowSize.value = { width, height }
    
    // Update device type based on width
    if (width < 768) {
      setDeviceType('mobile')
    } else if (width < 1024) {
      setDeviceType('tablet')
    } else {
      setDeviceType('desktop')
    }
  }
  
  const initializeApp = () => {
    // Load saved preferences
    const savedTheme = localStorage.getItem('theme') as 'light' | 'dark' || 'light'
    const savedLanguage = localStorage.getItem('language') || 'en'
    const savedSidebarState = localStorage.getItem('sidebarCollapsed') === 'true'
    
    setTheme(savedTheme)
    setLanguage(savedLanguage)
    setSidebarCollapsed(savedSidebarState)
    
    // Set up window resize listener
    const handleResize = () => {
      updateWindowSize(window.innerWidth, window.innerHeight)
    }
    
    window.addEventListener('resize', handleResize)
    handleResize() // Initial call
    
    return () => {
      window.removeEventListener('resize', handleResize)
    }
  }
  
  return {
    // State
    isLoading: readonly(isLoading),
    loadingText: readonly(loadingText),
    sidebarCollapsed: readonly(sidebarCollapsed),
    theme: readonly(theme),
    language: readonly(language),
    breadcrumb: readonly(breadcrumb),
    notifications: readonly(notifications),
    cachedViews: readonly(cachedViews),
    visitedViews: readonly(visitedViews),
    deviceType: readonly(deviceType),
    windowSize: readonly(windowSize),
    
    // Getters
    isMobile,
    isTablet,
    isDesktop,
    unreadNotifications,
    
    // Actions
    setLoading,
    toggleSidebar,
    setSidebarCollapsed,
    setTheme,
    toggleTheme,
    setLanguage,
    setBreadcrumb,
    addNotification,
    markNotificationAsRead,
    markAllNotificationsAsRead,
    removeNotification,
    clearNotifications,
    addCachedView,
    removeCachedView,
    clearCachedViews,
    addVisitedView,
    setDeviceType,
    updateWindowSize,
    initializeApp
  }
})
```

### Form State Management

```typescript
// stores/form.ts
import { defineStore } from 'pinia'
import { ref, computed, reactive } from 'vue'
import type { FormInstance, FormRules } from 'element-plus'
import { ElMessage } from 'element-plus'

interface FormState {
  [key: string]: any
}

interface FormConfig {
  id: string
  data: FormState
  rules?: FormRules
  loading?: boolean
  errors?: Record<string, string[]>
  touched?: Record<string, boolean>
  dirty?: boolean
}

export const useFormStore = defineStore('form', () => {
  // State
  const forms = ref<Map<string, FormConfig>>(new Map())
  const globalLoading = ref(false)
  
  // Getters
  const getForm = computed(() => {
    return (formId: string) => forms.value.get(formId)
  })
  
  const isFormValid = computed(() => {
    return (formId: string) => {
      const form = forms.value.get(formId)
      if (!form) return false
      
      return Object.keys(form.errors || {}).length === 0
    }
  })
  
  const isFormDirty = computed(() => {
    return (formId: string) => {
      const form = forms.value.get(formId)
      return form?.dirty || false
    }
  })
  
  const hasFormErrors = computed(() => {
    return (formId: string) => {
      const form = forms.value.get(formId)
      return form && form.errors && Object.keys(form.errors).length > 0
    }
  })
  
  // Actions
  const createForm = (formId: string, initialData: FormState, rules?: FormRules) => {
    const formConfig: FormConfig = {
      id: formId,
      data: reactive({ ...initialData }),
      rules,
      loading: false,
      errors: {},
      touched: {},
      dirty: false
    }
    
    forms.value.set(formId, formConfig)
    return formConfig
  }
  
  const updateFormData = (formId: string, data: Partial<FormState>) => {
    const form = forms.value.get(formId)
    if (form) {
      Object.assign(form.data, data)
      form.dirty = true
      
      // Mark fields as touched
      Object.keys(data).forEach(key => {
        if (form.touched) {
          form.touched[key] = true
        }
      })
    }
  }
  
  const setFormField = (formId: string, field: string, value: any) => {
    const form = forms.value.get(formId)
    if (form) {
      form.data[field] = value
      form.dirty = true
      
      if (form.touched) {
        form.touched[field] = true
      }
      
      // Clear field error when value changes
      if (form.errors && form.errors[field]) {
        delete form.errors[field]
      }
    }
  }
  
  const setFormLoading = (formId: string, loading: boolean) => {
    const form = forms.value.get(formId)
    if (form) {
      form.loading = loading
    }
  }
  
  const setFormErrors = (formId: string, errors: Record<string, string[]>) => {
    const form = forms.value.get(formId)
    if (form) {
      form.errors = errors
    }
  }
  
  const clearFormErrors = (formId: string, field?: string) => {
    const form = forms.value.get(formId)
    if (form && form.errors) {
      if (field) {
        delete form.errors[field]
      } else {
        form.errors = {}
      }
    }
  }
  
  const validateForm = async (formId: string, formRef?: FormInstance) => {
    const form = forms.value.get(formId)
    if (!form) return false
    
    try {
      if (formRef) {
        await formRef.validate()
      }
      
      form.errors = {}
      return true
    } catch (error: any) {
      // Handle validation errors
      if (error.fields) {
        const errors: Record<string, string[]> = {}
        Object.keys(error.fields).forEach(field => {
          errors[field] = error.fields[field].map((err: any) => err.message)
        })
        form.errors = errors
      }
      
      return false
    }
  }
  
  const submitForm = async (
    formId: string,
    submitFn: (data: FormState) => Promise<any>,
    formRef?: FormInstance
  ) => {
    const form = forms.value.get(formId)
    if (!form) {
      throw new Error(`Form ${formId} not found`)
    }
    
    try {
      form.loading = true
      
      // Validate form first
      const isValid = await validateForm(formId, formRef)
      if (!isValid) {
        ElMessage.error('Please fix form errors before submitting')
        return { success: false, errors: form.errors }
      }
      
      // Submit form
      const result = await submitFn(form.data)
      
      // Reset form state on successful submission
      form.dirty = false
      form.errors = {}
      form.touched = {}
      
      ElMessage.success('Form submitted successfully')
      
      return { success: true, data: result }
    } catch (error: any) {
      // Handle server validation errors
      if (error.response?.data?.errors) {
        form.errors = error.response.data.errors
      }
      
      ElMessage.error(error.message || 'Form submission failed')
      
      return { success: false, error: error.message, errors: form.errors }
    } finally {
      form.loading = false
    }
  }
  
  const resetForm = (formId: string, initialData?: FormState) => {
    const form = forms.value.get(formId)
    if (form) {
      if (initialData) {
        Object.assign(form.data, initialData)
      }
      
      form.errors = {}
      form.touched = {}
      form.dirty = false
      form.loading = false
    }
  }
  
  const removeForm = (formId: string) => {
    forms.value.delete(formId)
  }
  
  const clearAllForms = () => {
    forms.value.clear()
  }
  
  return {
    // State
    forms: readonly(forms),
    globalLoading: readonly(globalLoading),
    
    // Getters
    getForm,
    isFormValid,
    isFormDirty,
    hasFormErrors,
    
    // Actions
    createForm,
    updateFormData,
    setFormField,
    setFormLoading,
    setFormErrors,
    clearFormErrors,
    validateForm,
    submitForm,
    resetForm,
    removeForm,
    clearAllForms
  }
})
```

## Advanced Store Patterns

### Data Table Store

```typescript
// stores/dataTable.ts
import { defineStore } from 'pinia'
import { ref, computed, reactive } from 'vue'
import type { TableColumnCtx } from 'element-plus'

interface TableConfig {
  id: string
  data: any[]
  total: number
  loading: boolean
  pagination: {
    page: number
    size: number
    sizes: number[]
  }
  sorting: {
    prop: string
    order: 'ascending' | 'descending' | null
  }
  filters: Record<string, any>
  selection: any[]
  expandedRows: any[]
}

export const useDataTableStore = defineStore('dataTable', () => {
  // State
  const tables = ref<Map<string, TableConfig>>(new Map())
  
  // Getters
  const getTable = computed(() => {
    return (tableId: string) => tables.value.get(tableId)
  })
  
  const getTableData = computed(() => {
    return (tableId: string) => {
      const table = tables.value.get(tableId)
      return table?.data || []
    }
  })
  
  const getTablePagination = computed(() => {
    return (tableId: string) => {
      const table = tables.value.get(tableId)
      return table?.pagination
    }
  })
  
  const isTableLoading = computed(() => {
    return (tableId: string) => {
      const table = tables.value.get(tableId)
      return table?.loading || false
    }
  })
  
  // Actions
  const createTable = (tableId: string, config: Partial<TableConfig> = {}) => {
    const defaultConfig: TableConfig = {
      id: tableId,
      data: [],
      total: 0,
      loading: false,
      pagination: {
        page: 1,
        size: 20,
        sizes: [10, 20, 50, 100]
      },
      sorting: {
        prop: '',
        order: null
      },
      filters: {},
      selection: [],
      expandedRows: []
    }
    
    const tableConfig = { ...defaultConfig, ...config }
    tables.value.set(tableId, reactive(tableConfig))
    
    return tableConfig
  }
  
  const setTableData = (tableId: string, data: any[], total?: number) => {
    const table = tables.value.get(tableId)
    if (table) {
      table.data = data
      if (total !== undefined) {
        table.total = total
      }
    }
  }
  
  const setTableLoading = (tableId: string, loading: boolean) => {
    const table = tables.value.get(tableId)
    if (table) {
      table.loading = loading
    }
  }
  
  const updatePagination = (tableId: string, page?: number, size?: number) => {
    const table = tables.value.get(tableId)
    if (table) {
      if (page !== undefined) {
        table.pagination.page = page
      }
      if (size !== undefined) {
        table.pagination.size = size
      }
    }
  }
  
  const updateSorting = (tableId: string, prop: string, order: 'ascending' | 'descending' | null) => {
    const table = tables.value.get(tableId)
    if (table) {
      table.sorting.prop = prop
      table.sorting.order = order
    }
  }
  
  const updateFilters = (tableId: string, filters: Record<string, any>) => {
    const table = tables.value.get(tableId)
    if (table) {
      table.filters = { ...table.filters, ...filters }
    }
  }
  
  const clearFilters = (tableId: string) => {
    const table = tables.value.get(tableId)
    if (table) {
      table.filters = {}
    }
  }
  
  const setSelection = (tableId: string, selection: any[]) => {
    const table = tables.value.get(tableId)
    if (table) {
      table.selection = selection
    }
  }
  
  const setExpandedRows = (tableId: string, expandedRows: any[]) => {
    const table = tables.value.get(tableId)
    if (table) {
      table.expandedRows = expandedRows
    }
  }
  
  const loadTableData = async (
    tableId: string,
    loadFn: (params: any) => Promise<{ data: any[], total: number }>
  ) => {
    const table = tables.value.get(tableId)
    if (!table) return
    
    try {
      table.loading = true
      
      const params = {
        page: table.pagination.page,
        size: table.pagination.size,
        sort: table.sorting.prop,
        order: table.sorting.order,
        ...table.filters
      }
      
      const result = await loadFn(params)
      
      table.data = result.data
      table.total = result.total
    } catch (error) {
      console.error('Failed to load table data:', error)
      table.data = []
      table.total = 0
    } finally {
      table.loading = false
    }
  }
  
  const refreshTable = async (
    tableId: string,
    loadFn: (params: any) => Promise<{ data: any[], total: number }>
  ) => {
    const table = tables.value.get(tableId)
    if (table) {
      table.pagination.page = 1
      await loadTableData(tableId, loadFn)
    }
  }
  
  const removeTable = (tableId: string) => {
    tables.value.delete(tableId)
  }
  
  return {
    // State
    tables: readonly(tables),
    
    // Getters
    getTable,
    getTableData,
    getTablePagination,
    isTableLoading,
    
    // Actions
    createTable,
    setTableData,
    setTableLoading,
    updatePagination,
    updateSorting,
    updateFilters,
    clearFilters,
    setSelection,
    setExpandedRows,
    loadTableData,
    refreshTable,
    removeTable
  }
})
```

## Store Composition and Plugins

### Store Composition Pattern

```typescript
// composables/useStores.ts
import { useAuthStore } from '@/stores/auth'
import { useAppStore } from '@/stores/app'
import { useFormStore } from '@/stores/form'
import { useDataTableStore } from '@/stores/dataTable'

// Composed store hook for common operations
export const useStores = () => {
  const authStore = useAuthStore()
  const appStore = useAppStore()
  const formStore = useFormStore()
  const tableStore = useDataTableStore()
  
  // Combined getters
  const isAppReady = computed(() => {
    return !appStore.isLoading && authStore.isAuthenticated
  })
  
  const userPermissions = computed(() => {
    return authStore.permissions
  })
  
  // Combined actions
  const initializeApp = async () => {
    try {
      appStore.setLoading(true, 'Initializing application...')
      
      // Initialize auth
      authStore.initializeAuth()
      
      // Initialize app settings
      const cleanup = appStore.initializeApp()
      
      // Load user-specific data if authenticated
      if (authStore.isAuthenticated) {
        await loadUserData()
      }
      
      return cleanup
    } finally {
      appStore.setLoading(false)
    }
  }
  
  const loadUserData = async () => {
    // Load user-specific data, preferences, etc.
    try {
      // Example: Load user notifications
      const notifications = await api.getUserNotifications()
      notifications.forEach(notification => {
        appStore.addNotification(notification)
      })
    } catch (error) {
      console.error('Failed to load user data:', error)
    }
  }
  
  const logout = async () => {
    try {
      await authStore.logout()
      
      // Clear app state
      appStore.clearNotifications()
      appStore.clearCachedViews()
      formStore.clearAllForms()
      
      // Redirect to login
      router.push('/login')
    } catch (error) {
      console.error('Logout error:', error)
    }
  }
  
  return {
    // Stores
    authStore,
    appStore,
    formStore,
    tableStore,
    
    // Combined getters
    isAppReady,
    userPermissions,
    
    // Combined actions
    initializeApp,
    loadUserData,
    logout
  }
}
```

### Persistence Plugin

```typescript
// plugins/persistence.ts
import type { PiniaPluginContext } from 'pinia'

interface PersistenceOptions {
  key?: string
  storage?: Storage
  paths?: string[]
  beforeRestore?: (context: PiniaPluginContext) => void
  afterRestore?: (context: PiniaPluginContext) => void
}

export const createPersistedState = (options: PersistenceOptions = {}) => {
  return (context: PiniaPluginContext) => {
    const { store, options: storeOptions } = context
    
    // Check if store should be persisted
    const persistOptions = (storeOptions as any).persist
    if (!persistOptions) return
    
    const {
      key = store.$id,
      storage = localStorage,
      paths = [],
      beforeRestore,
      afterRestore
    } = { ...options, ...persistOptions }
    
    // Restore state from storage
    const restore = () => {
      try {
        beforeRestore?.(context)
        
        const stored = storage.getItem(key)
        if (stored) {
          const state = JSON.parse(stored)
          
          if (paths.length > 0) {
            // Restore only specified paths
            paths.forEach(path => {
              if (state[path] !== undefined) {
                store.$patch({ [path]: state[path] })
              }
            })
          } else {
            // Restore entire state
            store.$patch(state)
          }
        }
        
        afterRestore?.(context)
      } catch (error) {
        console.error('Failed to restore state:', error)
      }
    }
    
    // Save state to storage
    const save = () => {
      try {
        let stateToSave = store.$state
        
        if (paths.length > 0) {
          // Save only specified paths
          stateToSave = paths.reduce((acc, path) => {
            if (store.$state[path] !== undefined) {
              acc[path] = store.$state[path]
            }
            return acc
          }, {} as any)
        }
        
        storage.setItem(key, JSON.stringify(stateToSave))
      } catch (error) {
        console.error('Failed to save state:', error)
      }
    }
    
    // Restore state on initialization
    restore()
    
    // Save state on changes
    store.$subscribe((mutation, state) => {
      save()
    })
  }
}

// Usage in store
export const useAuthStore = defineStore('auth', () => {
  // ... store implementation
}, {
  persist: {
    key: 'auth-store',
    storage: localStorage,
    paths: ['user', 'token', 'permissions']
  }
})
```

### DevTools Integration

```typescript
// plugins/devtools.ts
import type { PiniaPluginContext } from 'pinia'

export const devtoolsPlugin = (context: PiniaPluginContext) => {
  const { store } = context
  
  // Add custom devtools integration
  if (process.env.NODE_ENV === 'development') {
    // Add store to window for debugging
    if (typeof window !== 'undefined') {
      window.__PINIA_STORES__ = window.__PINIA_STORES__ || {}
      window.__PINIA_STORES__[store.$id] = store
    }
    
    // Log store actions
    store.$onAction(({ name, args, after, onError }) => {
      console.group(`ðŸª Store Action: ${store.$id}.${name}`)
      console.log('Arguments:', args)
      
      after((result) => {
        console.log('Result:', result)
        console.groupEnd()
      })
      
      onError((error) => {
        console.error('Error:', error)
        console.groupEnd()
      })
    })
    
    // Log state changes
    store.$subscribe((mutation, state) => {
      console.log(`ðŸ”„ State Change in ${store.$id}:`, {
        type: mutation.type,
        payload: mutation.payload,
        newState: state
      })
    })
  }
}
```

## Integration with Element Plus Components

### Form Integration Example

```vue
<!-- components/UserForm.vue -->
<template>
  <el-form
    ref="formRef"
    :model="formData"
    :rules="formRules"
    :loading="formLoading"
    label-width="120px"
    @submit.prevent="handleSubmit"
  >
    <el-form-item label="Name" prop="name">
      <el-input
        v-model="formData.name"
        placeholder="Enter user name"
        @blur="handleFieldBlur('name')"
      />
    </el-form-item>
    
    <el-form-item label="Email" prop="email">
      <el-input
        v-model="formData.email"
        type="email"
        placeholder="Enter email address"
        @blur="handleFieldBlur('email')"
      />
    </el-form-item>
    
    <el-form-item label="Role" prop="role">
      <el-select
        v-model="formData.role"
        placeholder="Select user role"
        style="width: 100%"
      >
        <el-option label="User" value="user" />
        <el-option label="Admin" value="admin" />
        <el-option label="Moderator" value="moderator" />
      </el-select>
    </el-form-item>
    
    <el-form-item>
      <el-button type="primary" @click="handleSubmit" :loading="formLoading">
        {{ isEdit ? 'Update' : 'Create' }} User
      </el-button>
      <el-button @click="handleReset">Reset</el-button>
    </el-form-item>
  </el-form>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue'
import type { FormInstance, FormRules } from 'element-plus'
import { useFormStore } from '@/stores/form'
import { userApi } from '@/api/users'

const props = defineProps({
  userId: String,
  isEdit: Boolean
})

const emit = defineEmits(['success', 'error'])

const formRef = ref<FormInstance>()
const formStore = useFormStore()

const FORM_ID = 'user-form'

// Form configuration
const initialData = {
  name: '',
  email: '',
  role: 'user'
}

const formRules: FormRules = {
  name: [
    { required: true, message: 'Name is required', trigger: 'blur' },
    { min: 2, max: 50, message: 'Name must be 2-50 characters', trigger: 'blur' }
  ],
  email: [
    { required: true, message: 'Email is required', trigger: 'blur' },
    { type: 'email', message: 'Invalid email format', trigger: 'blur' }
  ],
  role: [
    { required: true, message: 'Role is required', trigger: 'change' }
  ]
}

// Create form in store
const form = formStore.createForm(FORM_ID, initialData, formRules)

// Computed properties
const formData = computed(() => form.data)
const formLoading = computed(() => form.loading || false)
const formErrors = computed(() => form.errors || {})

// Methods
const handleFieldBlur = (field: string) => {
  // Mark field as touched
  if (form.touched) {
    form.touched[field] = true
  }
}

const handleSubmit = async () => {
  const submitFn = props.isEdit
    ? (data: any) => userApi.updateUser(props.userId!, data)
    : (data: any) => userApi.createUser(data)
  
  const result = await formStore.submitForm(FORM_ID, submitFn, formRef.value)
  
  if (result.success) {
    emit('success', result.data)
  } else {
    emit('error', result.error)
  }
}

const handleReset = () => {
  formStore.resetForm(FORM_ID, initialData)
  formRef.value?.resetFields()
}

const loadUserData = async () => {
  if (props.isEdit && props.userId) {
    try {
      formStore.setFormLoading(FORM_ID, true)
      const response = await userApi.getUser(props.userId)
      formStore.updateFormData(FORM_ID, response.data)
    } catch (error) {
      console.error('Failed to load user data:', error)
    } finally {
      formStore.setFormLoading(FORM_ID, false)
    }
  }
}

// Lifecycle
onMounted(() => {
  loadUserData()
})

onUnmounted(() => {
  formStore.removeForm(FORM_ID)
})
</script>
```

### Table Integration Example

```vue
<!-- components/UserTable.vue -->
<template>
  <div class="user-table">
    <!-- Table toolbar -->
    <div class="table-toolbar">
      <el-row :gutter="16" justify="space-between">
        <el-col :span="12">
          <el-input
            v-model="searchQuery"
            placeholder="Search users..."
            :prefix-icon="Search"
            @input="handleSearch"
            clearable
          />
        </el-col>
        <el-col :span="12" class="text-right">
          <el-button type="primary" :icon="Plus" @click="handleCreate">
            Add User
          </el-button>
          <el-button
            :icon="Refresh"
            @click="handleRefresh"
            :loading="tableLoading"
          >
            Refresh
          </el-button>
        </el-col>
      </el-row>
    </div>
    
    <!-- Data table -->
    <el-table
      :data="tableData"
      :loading="tableLoading"
      @sort-change="handleSortChange"
      @selection-change="handleSelectionChange"
      stripe
      border
    >
      <el-table-column type="selection" width="55" />
      
      <el-table-column
        prop="name"
        label="Name"
        sortable="custom"
        min-width="150"
      />
      
      <el-table-column
        prop="email"
        label="Email"
        sortable="custom"
        min-width="200"
      />
      
      <el-table-column
        prop="role"
        label="Role"
        width="120"
        :filters="roleFilters"
        :filter-method="filterRole"
      >
        <template #default="{ row }">
          <el-tag :type="getRoleType(row.role)">{{ row.role }}</el-tag>
        </template>
      </el-table-column>
      
      <el-table-column
        prop="status"
        label="Status"
        width="100"
        :filters="statusFilters"
        :filter-method="filterStatus"
      >
        <template #default="{ row }">
          <el-tag :type="row.active ? 'success' : 'danger'">
            {{ row.active ? 'Active' : 'Inactive' }}
          </el-tag>
        </template>
      </el-table-column>
      
      <el-table-column
        prop="createdAt"
        label="Created"
        width="180"
        sortable="custom"
      >
        <template #default="{ row }">
          {{ formatDate(row.createdAt) }}
        </template>
      </el-table-column>
      
      <el-table-column label="Actions" width="200" fixed="right">
        <template #default="{ row }">
          <el-button
            size="small"
            type="primary"
            :icon="Edit"
            @click="handleEdit(row)"
          >
            Edit
          </el-button>
          <el-button
            size="small"
            type="danger"
            :icon="Delete"
            @click="handleDelete(row)"
          >
            Delete
          </el-button>
        </template>
      </el-table-column>
    </el-table>
    
    <!-- Pagination -->
    <div class="table-pagination">
      <el-pagination
        v-model:current-page="currentPage"
        v-model:page-size="pageSize"
        :page-sizes="pageSizes"
        :total="total"
        layout="total, sizes, prev, pager, next, jumper"
        @size-change="handleSizeChange"
        @current-change="handlePageChange"
      />
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { useDataTableStore } from '@/stores/dataTable'
import { userApi } from '@/api/users'
import { ElMessage, ElMessageBox } from 'element-plus'
import {
  Search,
  Plus,
  Refresh,
  Edit,
  Delete
} from '@element-plus/icons-vue'
import { debounce } from 'lodash-es'

const emit = defineEmits(['create', 'edit'])

const tableStore = useDataTableStore()
const TABLE_ID = 'user-table'

// Create table in store
const table = tableStore.createTable(TABLE_ID, {
  pagination: {
    page: 1,
    size: 20,
    sizes: [10, 20, 50, 100]
  }
})

// Local state
const searchQuery = ref('')

// Computed properties
const tableData = computed(() => tableStore.getTableData(TABLE_ID))
const tableLoading = computed(() => tableStore.isTableLoading(TABLE_ID))
const pagination = computed(() => tableStore.getTablePagination(TABLE_ID))
const currentPage = computed({
  get: () => pagination.value?.page || 1,
  set: (value) => tableStore.updatePagination(TABLE_ID, value)
})
const pageSize = computed({
  get: () => pagination.value?.size || 20,
  set: (value) => tableStore.updatePagination(TABLE_ID, undefined, value)
})
const pageSizes = computed(() => pagination.value?.sizes || [10, 20, 50, 100])
const total = computed(() => table.total)

// Filter options
const roleFilters = [
  { text: 'Admin', value: 'admin' },
  { text: 'User', value: 'user' },
  { text: 'Moderator', value: 'moderator' }
]

const statusFilters = [
  { text: 'Active', value: true },
  { text: 'Inactive', value: false }
]

// Methods
const loadData = async () => {
  await tableStore.loadTableData(TABLE_ID, async (params) => {
    const response = await userApi.getUsers({
      ...params,
      search: searchQuery.value
    })
    
    return {
      data: response.data.users,
      total: response.data.total
    }
  })
}

const handleSearch = debounce(() => {
  currentPage.value = 1
  loadData()
}, 300)

const handleRefresh = () => {
  loadData()
}

const handleSortChange = ({ prop, order }) => {
  tableStore.updateSorting(TABLE_ID, prop, order)
  loadData()
}

const handleSelectionChange = (selection) => {
  tableStore.setSelection(TABLE_ID, selection)
}

const handlePageChange = (page) => {
  loadData()
}

const handleSizeChange = (size) => {
  currentPage.value = 1
  loadData()
}

const handleCreate = () => {
  emit('create')
}

const handleEdit = (row) => {
  emit('edit', row)
}

const handleDelete = async (row) => {
  try {
    await ElMessageBox.confirm(
      `Are you sure you want to delete user "${row.name}"?`,
      'Confirm Delete',
      {
        confirmButtonText: 'Delete',
        cancelButtonText: 'Cancel',
        type: 'warning'
      }
    )
    
    await userApi.deleteUser(row.id)
    ElMessage.success('User deleted successfully')
    
    // Reload data
    await loadData()
  } catch (error) {
    if (error !== 'cancel') {
      ElMessage.error('Failed to delete user')
    }
  }
}

const filterRole = (value, row) => {
  return row.role === value
}

const filterStatus = (value, row) => {
  return row.active === value
}

const getRoleType = (role) => {
  const types = {
    admin: 'danger',
    moderator: 'warning',
    user: 'info'
  }
  return types[role] || 'info'
}

const formatDate = (date) => {
  return new Date(date).toLocaleString()
}

// Lifecycle
onMounted(() => {
  loadData()
})

onUnmounted(() => {
  tableStore.removeTable(TABLE_ID)
})
</script>

<style scoped>
.user-table {
  padding: 20px;
}

.table-toolbar {
  margin-bottom: 20px;
}

.table-pagination {
  margin-top: 20px;
  text-align: right;
}

.text-right {
  text-align: right;
}
</style>
```

This comprehensive guide demonstrates how to effectively integrate Pinia with Element Plus, covering everything from basic setup to advanced patterns like form management, data tables, and store composition. The examples provide a solid foundation for building scalable, maintainable applications with excellent state management.